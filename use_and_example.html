<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>Usage</title>

  <style type="text/css">
    body {
      margin-top: 1.0em;
      background-color: #000000;
      font-family: Helvetica, Arial, FreeSans, san-serif;
      color: #ffffff;
    }
    #container {
      margin: 0 auto;
      width: 90%;
    }
    h1 { font-size: 3.8em; color: #ffffff; margin-bottom: 3px; }
    h1 .small { font-size: 0.4em; }
    h1 a { text-decoration: none }
    h2 { font-size: 1.5em; color: #ffffff; clear: both; }
    h3 { color: #ffffff; }
    img { float: left; }
    p { clear: both; }
    li { clear: both; }
    a { color: #0000ff; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
    .download { float: right; }
    pre { background: #000; color: #fff; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; }
  </style>
</head>

<body>
  <div id="container">


    <div>
    <a href="http://github.com/kyllikki/png23d"><img alt="PNG23D logo" title="PNG23D" src="png23d.png"/></a>
      <span class="small">by <a href="http://github.com/kyllikki">kyllikki</a></span>
    </div>


    <h1>Usage</h1>

    <h2>Introduction</h2>

    <p>Although the tool was primarily developed for 3D printing
    applications, the STL output is two maifold and most CAD
    applications will import the output correctly.</p>

    <p>Usage is based around the command line in a similar manner to
    the ImageMagick two dimensional image manipulation tool.</p>

    <p>The full set of available command line switches may be found in
    the <a href="png23d.1.html">man page</a> accompanying the program
    source.</p>

    <p>As outlined in the <a href="index.html">main overview</a>
    conversion is a five stage process each is detaild in their own
    secions below. The operations used to perform the conversion are:

      <dl>
	<dt><a href="#source_image">Source Image</a></dt>
	<dd>Read, decode and process the source image into a greyscale bitmap.</dd>

	<dt><a href="#mesh_generation">Mesh Generation</a></dt>
	<dd>Generate a <a href="http://en.wikipedia.org/wiki/Polygon_mesh">triangle mesh</a> creating a manifold polygon.</dd>

	<dt><a href="#mesh_indexing">Mesh Indexing</a></dt>
	<dd>Index the vetices of the generated mesh.</dd>
	
	<dt><a href="#mesh_simplification">Mesh Simplification</a></dt>
	<dd>Simplify the generated mesh.</dd>

	<dt><a href="#output">Output</a></dt>
	<dd>Write the generated mesh to output file in selected format.</dd>

      </dl>
    </p>

    <p>The -v switch can be used to increase the verbostiy of the tool
    and get some basic statistics and values about each stage of
    operation.</p>


    <h2>3D printing</h2>

    <p>If you are using the output from this tool for 3D printing some
    specific properties have been discovered (from
    printing <em>lots</em> of faliures!)

      <ul>
	<li>The output model should have an x/y approximate spatial
	  resolution of 0.5mm per pixel. i.e. if the output is to be
	  printed at 100mm across the input image should be 200 pixels
	  across.</li>

	<li>A spacial resolution of more than 0.3mm is pointless and
	simply results in huge output files which cannot be rendered
	or printed.</li>

	<li>Calculating how many layers (z resolution) at generation
	time avoids excessive model complexity and wasted render time
	later. i.e. if your slicing program is set for 0.4mm layers
	and the output model is 10mm high, more than 25 layers in the
	generated output is poinless and will introduce aliasing
	artifacts.</li>

      </ul>    
    </p>


    <h2 id="source_image">Source Image</h2>

    <p>The input file must be a PNG image that the libpng library can
    read and a filename must always be provided as a parameter. The
    image is converted into a 256 level grey scale image using
    libpng.</p>

    <p>The source filename may be given as a single - which indicates
    input will be taken from the standard input. This allows for an
    image conversion program to be chained with the png23d program.</p> 

    <p>The example here uses the imagemagick convert tool to convert a
    gif image to png output, with colour manipulation and cropping,
    and immediatly passes the generated image to png23d without an
    intermediate temporary file.
      <pre>convert JohnvonNeumann.gif -quantize GRAY -dither none -colors 256 -negate \
-crop 350x510+90+60 +repage png:- | ./png23d -t x -f surface -o stl -l 25 \
-d 9.6 -w 100 - JohnvonNeumann.stl</pre> 
       </p>

    <h2 id="mesh_generation">Mesh Generation</h2>

    <p>This part of the process has a large impact on the output and
    should be tailored to the final use of the model.</p>

    <p>The x and y components of the generated mesh are, in all cases,
    derived from the source images dimensions. For 3D printing these
    should be arranged to give around a 0.5mm spacial resolution in
    final scaled output (see the 3D printing section).</p>

    <p>The z component is synthesised form the source greyscale image
    levels. The number of levels is controlled by the -l parameter. To
    illustrate, if four layers are selected colours from 0-63 will
    generate mesh output on layer 1, 64-127 on layer 2 and so on.</p>

    <p>In adition to the number of layers a single colour may be
    selected, with the -t switch, as &quot;transparent&quot; which
    will result in no mesh being present at that x-y location. One
    oddity here is that if a single layer is specified and the
    transparancy is turned off (with -t x) the output will be a solid
    block.</p>

    <p>currently there are four generation methods implemented, two
    general purpose and two which operate on a single layer. These
    methods are selected with the -f parameter.</p>

    <dl>

      <dt>rect</dt>

      <dd>This finish can only be used on single layer output. The
      bitmap is considered one pixel at a time and runs of non
      transparent pixes are converted
      into <a href="http://en.wikipedia.org/wiki/Cuboid">retangular
      cuboids</a>. This finish is <em>only</em> useful with the rscad
      output type, specifying it with any other output type will
      generate an error.</dd>

      <dt>smooth</dt>
      <dd>This finish can only be used on single layer output. The non
      transparent areas of the bitmap are passed through
      the <a href="http://en.wikipedia.org/wiki/Marching_squares">marching
      squares</a> algorithm which produces a reasonable contour on the
      filled areas. This finish is the default and is especially good
      for converting 2D logos and text into a smooth contoured three
      dimensional extrusion suitable for use in OpenSCAD models.</dd>

      <dt>cube</dt>
      <dd>This finish may be used with any number of valid levels. The
      bitmap is scanned and the transparency of each unit voxel
      considerd (as defined by its x and y position in the bitmap and
      its colour value as the z component). The faces of an opaque
      voxel whose neighbours are transparent get that face added to
      the mesh (as two right angled triangles). This finish produces a
      manifold mesh with (potentially) many levels. Caution should be
      employed using this finish for non-synthetic image sources as
      the result may become extremly complex and challenging to
      simplify.</dd>

      <dt>surface</dt>
      <dd>This finish may be used with any number of valid
      levels. This finish is more suitable for
      complex <a href="http://en.wikipedia.org/wiki/Heightmap">heightfields</a>
      like photographic images (used for lithophane generation). It
      simply creates triangle strips between each set of four pixels
      within the image (the edges being combined with virtual zero
      height pixels to ensure the mesh is manifold). This produces
      results which can never have vertical sides but are not subject
      to the &quot;blocking&quot; effect the cube finish
      produces. </dd>
    </dl>

    <h2 id="mesh_indexing">Mesh Indexing</h2>

    <p>The indexing of the mesh is largely opaque to the user. This
    process costructs a face-vertex index for the triangular faces (facets)
    generated in the previous step. The process is greatly accelerated
    by the use of a bloom filter.</p>

    <p>The only tunable parameter to the indexing process is the -b
    switch, this switch controls the size and number of functions for
    the bloom filter (and hence its efectiveness). The default value
    of 2 generally gives satisfactory results. For <em>very</em>
    complex meshes this value may need to be increased to reduce the
    mesh indexing time at the cost of increased memory usage.</p>

    <h2 id="mesh_simplification">Mesh Simplification</h2>

    <p>This is controlled with the -O switch similar to the
    optimisation level of a compiler. As of version 1.1 only the
    values 0 and 1 are usable. The value 0 simply turns off any
    optimisation and skips simplification altogether.</p>

    <p>An optimisation level of 1 performs a half edge removal. Each
    vertex is visited and every neighbour vertex in the mesh used to
    create an edge. Each of these edges is considered for removal. If
    it is possible to remove the edge without damaging the topology of
    the mesh it is removed and the process repeated untill there are
    no more edges to consider.</p>

    <p>The simplification process by its nature increases the number
    of faces which are joind to a single vertex. The complexity of a
    single vertex is limited by the -c parameter which may be set to a
    value between 8 and 128. The default of 16 is is a reasonable
    compromise on mesh complexity and memory usage. Increasing this
    parameter may result in output meshes with fewer vertices
    but <em>will</em> consume large quantities of memory (on a 64bit
    system changing from 16 to 32 adds 128bytes per vertex or 24
    megabytes for a simple 200,000 vertex model)</p>

    <p>The edge removals can be visualised for debugging purposes by
    specifying a filename with the -m switch. Caution should be
    exercised as the resulting html files can be huge. To
    illistrate <a href="o.html">here is an example of the output</a>
    for the o.png test image. </p>

    <h2 id="output">Output</h2>

    <p>The output file may have any arbitrary filename which must be
    specified. The output filename may be given as a single - which
    indicates output will be sent from the standard output.</p>

    <p> The output file format is controlled by the -o switch. The file formats available as of version 1.1 are:<dl>
	<dt><b>stl</b></dt><dd><a href="http://en.wikipedia.org/wiki/STL_format">3D systems Stereolithography</a> in binary (The default)</dd>
	<dt><b>astl</b></dt><dd><a href="http://en.wikipedia.org/wiki/STL_format">3D systems Stereolithography</a> in ASCII</dd>
	<dt><b>scad</b></dt><dd><a href="http://www.openscad.org/">OpenSCAD</a> module describing a <a href="http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Primitive_Solids#polyhedron">polyhedron</a> in ASCII</dd>
	<dt><b>rscad</b></dt><dd><a href="http://www.openscad.org/">OpenSCAD</a> module describing union of <a href="http://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Primitive_Solids#cube">cubes</a> in ASCII</dd>
	<dt><b>pgm</b></dt><dd><a href="http://en.wikipedia.org/wiki/Portable_graymap">Netpbm</a> (PGM type) in ASCII</dd>
    </dl></p>

    <p>The output scaling for width, depth and height are controlled
    with the w,d,h switches respectively. It should be noted that
    these only control scaling applied to the output and not the size
    or complexity of the mesh. The values are dimensionless although
    convention in most of the supported output formats is one unit is
    one millimetre.</p>


  </div>

  
</body>
</html>
